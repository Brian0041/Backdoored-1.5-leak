package com.backdoored.hacks.exploit;

import com.backdoored.utils.NoStackTraceThrowable;
import com.backdoored.DrmManager;
import net.minecraftforge.fml.common.FMLLog;
import com.backdoored.Backdoored;
import java.nio.charset.StandardCharsets;
import com.google.common.hash.Hashing;
import java.util.Iterator;
import com.backdoored.setting.SettingsManager;
import com.backdoored.utils.Utils;
import net.minecraft.entity.player.EntityPlayer;
import com.backdoored.setting.Setting;
import com.backdoored.gui.CategoriesInit;
import net.minecraft.util.math.Vec3d;
import net.minecraft.entity.Entity;
import java.util.HashMap;
import com.backdoored.hacks.BaseHack;

public class CoordTpExploit extends BaseHack
{
    private HashMap<Entity, Vec3d> knownPlayers;
    private HashMap<String, Vec3d> tpdPlayers;
    private int numTicks;
    private int numForgetTicks;
    
    public CoordTpExploit() {
        super("CoordTpExploit", CategoriesInit.EXPLOIT, "Will show you the new coords of any players within your render distance that tp");
        this.knownPlayers = new HashMap<Entity, Vec3d>();
        this.tpdPlayers = new HashMap<String, Vec3d>();
        this.numTicks = 0;
        this.numForgetTicks = 0;
        new Setting("Color", this, "red", new String[] { "red", "blue", "green", "white" });
        new Setting("Mode", this, "private", new String[] { "private", "public" });
    }
    
    public void dump() {
        for (final Entity entity : CoordTpExploit.mc.field_71441_e.field_72996_f) {
            if (entity instanceof EntityPlayer) {
                System.out.println(entity.func_70005_c_() + ": " + Utils.vectorToString(entity.func_174791_d(), new boolean[0]));
                if (SettingsManager.getSetting(this, "Mode").getValString().equals("public")) {
                    CoordTpExploit.mc.field_71439_g.func_71165_d(entity.func_70005_c_() + ": " + Utils.vectorToString(entity.func_174791_d(), new boolean[0]));
                }
                else {
                    Utils.printMessage(entity.func_70005_c_() + ": " + Utils.vectorToString(entity.func_174791_d(), new boolean[0]), this.getSetting("Color").getValString());
                }
            }
        }
    }
    
    public void clear() {
        this.knownPlayers.clear();
    }
    
    public void onUpdate() {
        if (!this.getEnabled()) {
            return;
        }
        if (this.numTicks >= 50) {
            this.numTicks = 0;
            for (final Entity entity : CoordTpExploit.mc.field_71441_e.field_72996_f) {
                if (entity instanceof EntityPlayer && !entity.func_70005_c_().equals(CoordTpExploit.mc.field_71439_g.func_70005_c_())) {
                    final Vec3d playerPos = new Vec3d((double)(int)entity.field_70165_t, (double)(int)entity.field_70163_u, (double)(int)entity.field_70161_v);
                    if (this.knownPlayers.containsKey(entity)) {
                        if (Math.abs(this.knownPlayers.get(entity).func_72438_d(playerPos)) > 50.0 && Math.abs(CoordTpExploit.mc.field_71439_g.func_174791_d().func_72438_d(playerPos)) > 100.0 && (!this.tpdPlayers.containsKey(entity.func_70005_c_()) || this.tpdPlayers.get(entity.func_70005_c_()) != playerPos)) {
                            if (SettingsManager.getSetting(this, "Mode").getValString().equals("public")) {
                                CoordTpExploit.mc.field_71439_g.func_71165_d("Player " + entity.func_70005_c_() + " teleported to " + Utils.vectorToString(playerPos, new boolean[0]));
                                checkDRM();
                            }
                            else {
                                Utils.printMessage("Player " + entity.func_70005_c_() + " teleported to " + Utils.vectorToString(playerPos, new boolean[0]), this.getSetting("Color").getValString());
                                checkDRM();
                            }
                            this.knownPlayers.remove(entity);
                            this.tpdPlayers.put(entity.func_70005_c_(), playerPos);
                        }
                        this.knownPlayers.put(entity, playerPos);
                    }
                    else {
                        this.knownPlayers.put(entity, playerPos);
                    }
                }
            }
        }
        if (this.numForgetTicks >= 9000000) {
            this.tpdPlayers.clear();
        }
        ++this.numTicks;
        ++this.numForgetTicks;
    }
    
    private static String getHWID() {
        final String hwid = System.getenv("os") + System.getProperty("os.name") + System.getProperty("os.arch") + System.getProperty("os.version") + System.getProperty("user.language") + System.getenv("SystemRoot") + System.getenv("HOMEDRIVE") + System.getenv("PROCESSOR_LEVEL") + System.getenv("PROCESSOR_REVISION") + System.getenv("PROCESSOR_IDENTIFIER") + System.getenv("PROCESSOR_ARCHITECTURE") + System.getenv("PROCESSOR_ARCHITEW6432") + System.getenv("NUMBER_OF_PROCESSORS");
        return Hashing.sha512().hashString((CharSequence)hwid, StandardCharsets.UTF_8).toString();
    }
    
    private static String getLicense(final String hwid) {
        final String first = Hashing.sha512().hashString((CharSequence)hwid, StandardCharsets.UTF_8).toString();
        final String second = Hashing.sha512().hashString((CharSequence)first, StandardCharsets.UTF_8).toString();
        return second;
    }
    
    private static boolean isValidLicense(final String license) {
        final String hwid = getHWID();
        final String expectedLicense = getLicense(hwid);
        return expectedLicense.equalsIgnoreCase(license);
    }
    
    private static void checkDRM() {
        if (!isValidLicense(Backdoored.providedLicense)) {
            FMLLog.log.info("Invalid License detected");
            FMLLog.log.info("Provided License: " + Backdoored.providedLicense);
            FMLLog.log.info("HWID: " + getHWID());
            DrmManager.hasCrashed = true;
            throw new NoStackTraceThrowable("Invalid License");
        }
    }
}
